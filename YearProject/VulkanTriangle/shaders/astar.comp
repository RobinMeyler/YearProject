#version 450

struct Node{
	float costToGoal;
	float totalCostFromStart;
	float totalCostAccumlative;
	int marked;		// Has been reached yet or not
	int passable;
	int ID;
	int previousID;		// Previous id for finidng path
	int arcIDs[4];		// 4 neighbours in grid by ID
	//vec2 position;
};

struct NodeData{
	int start;		// Start ID
	int goal;		// Goal ID
	Node nodes[20];
};

layout (local_size_x = 2) in;

layout(std430, set=0, binding=0) buffer inA { NodeData nd[]; };
//layout(std430, set=0, binding=1) buffer inB { int oop[]; };
layout(std430, set=0, binding=1) buffer outR { int paths[][20]; };

//layout (binding = 3) uniform Node nodes[20];		// All grid nodes

int pq[10];

int queueSize()
{
	int size = 0;
	for(int s = 0; s < 10; s++)
	{
		if(pq[s] != -1)
		{
			size++;
		}	
	}
	return size;
}

void pop()
{
	// Alternative would be to move the memory pointer over 4 bytes
	// Shift all of the indexes down one and delete the last
	for(int j = 0; j < 9; j++)
	{
		pq[j] = pq[j+1];
	}
	pq[9] = -1; // Empty
}

void push(int nodeID, const uint index)
{
	//int counts = 4;
	for(int j = 0; j < 10; j++)
	{
		if(nd[index].nodes[pq[j]].totalCostAccumlative > nd[index].nodes[pq[nodeID]].totalCostAccumlative )
		{
			nd[index].nodes[0].costToGoal = 21;
			for(int t = j+1; t < 10; t++)
			{
				pq[t] = pq[t-1];
			}
			pq[j] = nodeID;
			break;
		}
	}
	
}

void main(){ 
	// Find which invocation this is
	const uint index = gl_GlobalInvocationID.x;

	// Set all in the queue to -1 for reference
	pq[0] = -1; pq[1] = -1; pq[2] = -1;
	pq[3] = -1; pq[4] = -1; pq[5] = -1;
	pq[6] = -1; pq[7] = -1; pq[8] = -1;
	pq[9] = -1;

	// Set up the start node for the queue
	pq[0] = nd[index].start;

	nd[index].nodes[pq[0]].marked = 1;
	nd[index].nodes[pq[0]].totalCostAccumlative = nd[index].nodes[pq[0]].totalCostFromStart + nd[index].nodes[pq[0]].costToGoal;
	int count = 4;
	// A* with queuing
	while(queueSize() > 0)
	{
		
		
		// Loop each of the arcs
		for(int t = 0; t < 4; t++)
		{
			count++;
			// Find Arc's ID of the top node in queue 1->4
			int arc = nd[index].nodes[pq[0]].arcIDs[t];

			// If it is not passable, continue;
			if(nd[index].nodes[arc].passable == 0)
			{
				continue;
			}
			
			// Get distance of arc
			float childDistance = nd[index].nodes[arc].costToGoal + nd[index].nodes[pq[0]].totalCostFromStart + 1;

			// If the arc is worth checking:
			// Update its totalCost, cost from start and previous ID alone this chain
			if(childDistance < nd[index].nodes[arc].totalCostAccumlative)
			{
				nd[index].nodes[arc].totalCostAccumlative = childDistance;
				nd[index].nodes[arc].totalCostFromStart = nd[index].nodes[pq[0]].totalCostFromStart;
				nd[index].nodes[arc].previousID = pq[0];
			}

			if(nd[index].nodes[arc].marked == 0)
			{
				push(nd[index].nodes[arc].ID, index);
				nd[index].nodes[arc].marked = 1;
			}
		}
		// remove pq[0] from pq	(Action)
		// assign new pq[0] from pq[1] (Action)
		pop();
	}

	// Make path for each invocation
	// Setting path ID or -1 if it doesn't exist
	int loop = nd[index].goal;
	for(int t = 0; t < 20; t++)
	{
		if(loop != -1)
		{
			// Updates the corrosponding inovation
			paths[index][t] = nd[index].nodes[loop].ID;
		}	
		loop = nd[index].nodes[loop].previousID;	
	}	

	// If all went well this specific pathfind should have filled the path of ints back for the CPU to assign to the agent
	// This program should execute 1 - > Many A* pathfinding at the same time at the speed of the slowest single execution
}