// Author: Robin Meyler
// Date: 2020/2021

#version 450

struct Node{
	float costToGoal;
	float totalCostFromStart;
	float totalCostAccumlative;
	int marked;		// Has been reached yet or not
	int passable;
	int ID;
	int previousID;		// Previous id for finding path
	int arcIDs[4];		// 4 neighbours in grid by ID
	vec2 position;
};

struct NodeData{
	int start;		// Start ID
	int goal;		// Goal ID
	Node nodes[10000];
};

struct Path{
    int pathList[625];
};

layout(std430, set=0, binding=0) buffer inA { NodeData nd[]; };
layout(std430, set=0, binding=1) buffer outR { Path paths[]; };

// layout(std430, set=0, binding=1) buffer inB { int oop[]; };
// layout (binding = 3) uniform Node nodes[20];					// All grid nodes

int pq[150];
int count = 0;
int leave = 0;
int queueSize()
{
	int size = 0;
	for(int s = 0; s < 150; s++)
	{
		if(pq[s] != 0)
		{
			size++;
		}	
	}
	return size;
}

void pop(const uint index)
{
	// Alternative would be to move the memory pointer over 4 bytes
	// Shift all of the indexes down one and delete the last

	for(int j = 0; j < 149; j++)
	{
		pq[j] = pq[j+1];
	}
	pq[149] = 0; // Empty
}

void push(const uint index, int nodeID)
{	
	leave = nodeID;
	for(int j = 1; j < 150; j++)
	{
		if(pq[j] != -1)
		{
			if(nd[index].nodes[pq[j]].totalCostAccumlative > nd[index].nodes[nodeID].totalCostAccumlative )
			{	
				int temp = j;
				for(int t = 149; t > 1; t--)
				{
					if((t) == (temp))
					{
						break;
					}
					pq[t] = pq[t-1];
				}
				pq[j] = nodeID;
				return;
			}
		}
		else
		{
			pq[j] = nodeID;
			return;
		}
	}
	pq[149] = nodeID;
	return;
}

void main(){ 
	// Find which invocation this is
	const uint index = gl_GlobalInvocationID.x;

	// Set all in the queue to -1 for reference
	for(int j = 0; j < 150; j++)
	{
		pq[j] = -1;
	}

	// Set up the start node for the queue
	pq[0] = nd[index].start;
	nd[index].nodes[pq[0]].totalCostFromStart = 0;
	nd[index].nodes[pq[0]].marked = 1;
	nd[index].nodes[pq[0]].totalCostAccumlative = nd[index].nodes[pq[0]].totalCostFromStart + nd[index].nodes[pq[0]].costToGoal;
	
	// A* with queuing
	while(queueSize() > 0)
	{
		count++;
		// Loop each of the arcs
		for(int g = 0; g < 4; g++)
		{
			// Find Arc's ID of the top node in queue 1->4
			int arc = nd[index].nodes[pq[0]].arcIDs[g];
			
			// No neighbour
			if(arc == -1)
			{
				continue;
			}
			// If it is not passable, continue;
			if(nd[index].nodes[arc].passable == 0)
			{
				continue;
			}
			
			// Get distance of arc
			float childDistance = nd[index].nodes[arc].costToGoal + nd[index].nodes[pq[0]].totalCostFromStart + 2;
			
			// If the arc is worth checking:
			// Update its totalCost, cost from start and previous ID alone this chain
			if(childDistance < nd[index].nodes[arc].totalCostAccumlative)
			{
				nd[index].nodes[arc].totalCostAccumlative = childDistance;
				nd[index].nodes[arc].totalCostFromStart = nd[index].nodes[pq[0]].totalCostFromStart + 2;
				nd[index].nodes[arc].previousID = pq[0];
			}
		
			if(nd[index].nodes[arc].marked == 0)
			{
				push(index, arc);	
				nd[index].nodes[arc].marked = 1;
			}
		}
		// remove pq[0] from pq	(Action)
		// assign new pq[0] from pq[1] (Action)	
		pop(index);
	}

	// Make path for each invocation
	// Setting path ID or -1 if it doesn't exist
	int loop = nd[index].goal;
	for(int t = 0; t < 625; t++)
	{
		loop = nd[index].nodes[loop].previousID;
		if(loop != -1)
		{
			// Updates the corrosponding inovation
			paths[index].pathList[t] = nd[index].nodes[loop].ID;
		}	
		else
		{
			break;
		}
	}	
	nd[index].nodes[0].totalCostFromStart = count;

	// For testing
	//nd[index].nodes[6].totalCostFromStart = count;
	//paths[index].pathList[2] = 31;
	// If all went well this specific pathfind should have filled the path of ints back for the CPU to assign to the agent
	// This program should execute 1 - > Many A* pathfinding at the same time at the speed of the slowest single execution
}